#!bin/bash/

# general function library for safe-remove

restorePath="${HOME}/deleted/.restore.info"
inBool=""
verboseBool=false
recurseBool=false
interactBool=false
optionsChecked=false

check() 
{
	if ! $optionsChecked; then
		while getopts "inovr" o
		do	case "$o" in
			n) inBool=true;;
			o) inBool=false;;
			i) interactBool=true;;
			v) verboseBool=true;;
			r) recurseBool=true;;
			*) echo -e "check usage: $(basename $0) [-i]: 'check in, aka remove' [-o]: 'check out, aka restore' [-v]: 'verbose mode' [-i]: 'interactive mode' [-r]: 'enable recursive action'.\nBoth remove and restore map to 'check', either may be used as long as the flags are utilized." >&2; exit 1;;
			esac
			optionsChecked=true
		done
		shift $(($OPTIND-1))
	fi;
	
	if [ "$#" -gt "1" ]; then
		for arg in "$@"; do
			if [ ! "$arg" == "$1" ] && [ ! -z "$arg" ]; then 
			check "$arg"; fi
		done
	fi

	if validate $1
	then
		if $inBool; then 
			fileId="$(basename ${1}_$(stat -c %i $1))"
		else fileId=$(basename $1); fi
	else exit; fi
	
	if $inBool
	then
		interact "remove: remove file '${1}'? y/n: "
		[ -d "${HOME}/deleted/" ] || mkdir "${HOME}/deleted/"
		echo "${fileId}:$(readlink -m $1)" >> $restorePath
		mv $1 "${HOME}/deleted/${fileId}"
		if $verboseBool; then echo "removed file."; fi
	elif ! $inBool
	then
		if [ -e $1 ] && getLine $fileId -q
		then
			returnPath=$(getLine $fileId | cut -d":" -f 2)
			if [ -e $returnPath ]; then
				read -p "File exists at location already. Do you want to overwrite? y/n: " reply; if [[ ! "${reply:0:1}" == [yY] ]]; then exit; fi;
			fi;

			mv "${HOME}/deleted/${fileId}" $returnPath
			getLine $fileId -v > tmp
			mv tmp $restorePath
			if $verboseBool; then echo "restored file."; fi
		else 
			errorMessage "restore" $1 "This file is not being managed by restore currently."
		fi
	fi
}

# parameters are file path, action, recurseBool
validate() 
{
	if $inBool; then action="remove"
	else action="restore"; fi

	if [ "$1" == "" ]; then 
	errorMessage $action $1 "Please supply a file name"; fi;
	
	if [ -f $1 ]; then
		case $(basename $1) in
			"remove") errorMessage $action $1 "I am not going to ${action} myself.";;
			"restore") errorMessage $action $1 "I am not going to ${action} myself.";;
			"libSafe") errorMessage $action $1 "Back off dude. That is my library.";;
		esac		
		return 0;
	else
		if [ -d $1 ]; then
			if ! $recurseBool; then errorMessage $action $1 "Is a directory"; 
			else 
				interact "remove: descend into directory '${1}'? y/n: "
				check "${1}"*;
				if [ -z "$(ls -A $1)" ]; then
					interact "remove: remove empty directory '${1}'? y/n: "
					rmdir $1
				elif $interactBool; then echo "remove: ${1} directory is not empty"; fi
				exit;
			fi
		else errorMessage $action $1 "No such file or directory"
		fi
	fi
}

# parameters are action, file name, message
errorMessage() 
{
	echo "${1}: cannot ${1} '${2}': ${3}" >&2; exit 1
}

# parameter is message
interact()
{
	if $interactBool; then read -p "${1}" reply; if [[ ! "${reply:0:1}" == [yY] ]]; then exit; fi; fi;
}

# parameters are, fileId, option
getLine()
{
	grep $2 $1 $restorePath
}