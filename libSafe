#!bin/bash/

# general function library for safe-remove

restorePath="${HOME}/deleted/.restore.info"

# queries restore archive
list() 
{
	echo "There is nothing here yet!"
}

check() 
{
	inBool="";
	while getopts "io" o
	do	case "$o" in
		[i]) inBool=true;;
		[o]) inBool=false;;
		*) echo "didnt work...";;
		esac
	done
	shift $(($OPTIND-1))

	# check if file exists
	if validate $1
	then
		if $inBool; then 
			fileId="${1}_$(stat -c %i $1)"
		else fileId=$(basename $1); fi
	else exit; fi
	
	if $inBool
	then
		[ -d "${HOME}/deleted/" ] || mkdir "${HOME}/deleted/"
		echo "${fileId}:$(readlink -m $1)" >> $restorePath
		mv $1 "${HOME}/deleted/${fileId}"
	elif ! $inBool
	then
		if [ -e $1 ] && getLine $fileId -q
		then
			returnPath=$(getLine $fileId | cut -d":" -f 2)
			if [ -e $returnPath ]; then
				read -p "File exists at location already. Do you want to overwrite? y/n: " reply
				echo "${reply:0:1}" == [yY]
				if [[ ! "${reply:0:1}" == [yY] ]]; then exit; fi;
			fi;

			mv "${HOME}/deleted/${fileId}" $returnPath
			getLine $fileId -v > tmp
			mv tmp $restorePath
	
		else 
			echo "failure..."
		fi
	fi
}

# clear error conditions. If there is an error, return message
validate() 
{
	if [ "$1" == "" ]; then 
	echo "Please supply a file name";
	exit; fi;

	if [ -f $1 ]; then
		case $(basename $1) in
			"remove") echo "That isn't possible"; return 1;;
			"restore") echo "That isn't possible"; return 1;;
			"libSafe") echo "Back off dude"; return 1;;
		esac		
		return 0;
	else
		if $inBool; then action="remove"
		else action="restore"; fi
		if [ -d $1 ]; then
			echo "${action}: cannot ${action} '${1}': Is a directory"
		else echo "${action}: cannot ${action} '${1}': No such file or directory"
		fi
		return 1;
	fi
}

# parameters are, fileId, option
getLine()
{
	grep $2 $1 $restorePath
}

interact() 
{
	echo "There is nothing here yet!"
}

verbose() 
{  
	echo "There is nothing here yet!"
} 